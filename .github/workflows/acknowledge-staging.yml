name: Handle Vercel Deployments

on:
  deployment_status:
    types: [created]

permissions:
  contents: read
  deployments: write

concurrency:
  group: ${{ github.workflow }}-${{ github.event.deployment.id || github.event.deployment_status.id }}
  cancel-in-progress: false

jobs:
  update-github-deployment:
    if: github.event.deployment.payload.type == 'vercel'
    runs-on: ubuntu-latest
    steps:
      - name: Create or Update Managed Deployment
        uses: actions/github-script@v7
        with:
          script: |
            const { state, target_url } = context.payload.deployment_status;
            const { environment, ref, sha } = context.payload.deployment;
            const rawEnv = typeof environment === 'string' ? environment : '';
            const rawRef = typeof ref === 'string' ? ref : '';
            const deploymentRef = sha || rawRef;

            // Comprehensive list of states Vercel/GitHub might send
            // We include all possible states to avoid blocking Vercel's 'Deployment Checks' pipeline
            const allowedStates = new Set([
              'pending', 
              'in_progress', 
              'queued', 
              'success', 
              'failure', 
              'error', 
              'waiting',
              'inactive'
            ]);

            if (!allowedStates.has(state)) {
              console.log(`Skipping unexpected state: ${state}`);
              return;
            }

            if (!target_url && state === 'success') {
              core.setFailed('Missing target_url from Vercel deployment status event for successful deployment.');
              return;
            }

            // Map Vercel environments/branches to our managed GitHub environments
            let managedEnv = rawEnv || 'unknown';
            if (rawEnv.includes('preview')) {
              managedEnv = 'preview';
            } else if (rawRef === 'pre-staging' || rawEnv === 'staging') {
              managedEnv = 'staging';
            } else if (rawEnv === 'production') {
              if (rawRef === 'main') {
                managedEnv = 'production';
              } else {
                const safeRef = rawRef.replace(/[^a-zA-Z0-9._-]+/g, '-');
                managedEnv = `${rawEnv}-${safeRef}`;
                core.warning(`Unexpected production deployment triggered from non-main branch: ${rawRef}. Mapping to: ${managedEnv}`);
              }
            }

            managedEnv = managedEnv.replace(/[^a-zA-Z0-9._-]+/g, '-');

            try {
              let deploymentId;

              // Create a formal GitHub deployment for our tracked environment
              try {
                const deployment = await github.rest.repos.createDeployment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: deploymentRef,
                  environment: managedEnv,
                  description: `${managedEnv} deployment via Vercel`,
                  auto_merge: false,
                  required_contexts: []
                });

                if (deployment?.data?.id) {
                  deploymentId = deployment.data.id;
                } else if (deployment?.status === 202) {
                  console.log(`Deployment is queued (no ID yet). Context: ref=${ref}, managedEnv=${managedEnv}`);
                  return;
                } else {
                  throw new Error(`Deployment requested but no ID returned (Status: ${deployment?.status}). Context: ref=${deploymentRef}, managedEnv=${managedEnv}`);
                }
              } catch (error) {
                if (error?.status === 409) {
                  const existing = await github.rest.repos.listDeployments({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    ref: deploymentRef,
                    environment: managedEnv,
                    per_page: 1
                  });
                  deploymentId = existing?.data?.[0]?.id;
                }

                if (!deploymentId) {
                  throw error;
                }
              }

              // Build the status parameters
              const statusParams = {
                owner: context.repo.owner,
                repo: context.repo.repo,
                deployment_id: deploymentId,
                state: state,
                log_url: `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`,
                description: `Managed ${managedEnv} deployment ${state}`
              };

              // Safely validate and add target_url
              if (target_url) {
                let safeUrl = null;
                try {
                  const u = new URL(String(target_url));
                  if (u.protocol === 'https:' || u.protocol === 'http:') {
                    safeUrl = u.toString();
                  }
                } catch {
                  // ignore invalid URL
                }

                if (!safeUrl) {
                  core.warning(`Ignoring invalid target_url: ${String(target_url)}`);
                } else {
                  statusParams.environment_url = safeUrl;
                }
              }

              await github.rest.repos.createDeploymentStatus(statusParams);
              console.log(`Successfully acknowledged ${managedEnv} deployment with status ${state}`);
            } catch (error) {
              core.setFailed(`Failed to manage deployment status: ${error.message}`);
            }
