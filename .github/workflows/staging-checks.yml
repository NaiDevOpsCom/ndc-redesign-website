name: Quality Gates (Pre-Staging)

permissions:
  contents: read
  pull-requests: write

# Optimized concurrency - branch-based with global limit
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

on:
  push:
    branches: [pre-staging]
  pull_request:
    branches: [pre-staging]

# Global environment variables for all jobs
env:
  NODE_VERSION: "20"
  CACHE_VERSION: "v1"
  BUNDLE_SIZE_LIMIT_MB: "10"
  BUNDLE_SIZE_WARNING_MB: "8"

jobs:
  quality-checks:
    name: Comprehensive Quality Validation
    runs-on: ubuntu-latest
    timeout-minutes: 15

    strategy:
      matrix:
        check: [lint, types, tests, security, build, bundle]

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1 # Shallow for faster checkout

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: Install Dependencies
        run: npm ci --prefer-offline --no-audit

      # Optimized quality checks with job matrix
      - name: Lint and Format Check
        if: matrix.check == 'lint'
        run: |
          echo "üîç Running lint and format checks..."
          npm run check

          # Output summary for reporting
          echo "lint-status=success" >> $GITHUB_OUTPUT
          echo "lint-details=All linting checks passed" >> $GITHUB_OUTPUT

      - name: TypeScript Validation
        if: matrix.check == 'types'
        run: |
          echo "üî∑ Running TypeScript validation..."
          npm run typecheck

          # Count and report errors
          ERROR_COUNT=$(npx tsc --noEmit 2>&1 | grep -c "error TS" || echo "0")
          if [ "$ERROR_COUNT" -eq 0 ]; then
            echo "type-status=success" >> $GITHUB_OUTPUT
          else
            echo "type-status=failed" >> $GITHUB_OUTPUT
          fi
          echo "type-errors=$ERROR_COUNT" >> $GITHUB_OUTPUT

      - name: Unit Tests
        if: matrix.check == 'tests'
        run: |
          echo "üß™ Running unit tests..."
          npm test -- --coverage=lcov

          # Report test results
          if [ $? -eq 0 ]; then
            echo "test-status=success" >> $GITHUB_OUTPUT
          else
            echo "test-status=failed" >> $GITHUB_OUTPUT
            echo "::error::Unit tests failed"
            exit 1
          fi

      - name: Security Audit
        if: matrix.check == 'security'
        run: |
          echo "üõ°Ô∏è Running security audit..."

          # Run audit with JSON output for parsing
          AUDIT_RESULT=$(npm audit --audit-level=moderate --json || true)
          HIGH_VULNS=$(echo "$AUDIT_RESULT" | jq -r '.metadata.vulnerabilities.high // 0')
          MODERATE_VULNS=$(echo "$AUDIT_RESULT" | jq -r '.metadata.vulnerabilities.moderate // 0')

          if [ $((HIGH_VULNS + MODERATE_VULNS)) -eq 0 ]; then
            echo "security-status=success" >> $GITHUB_OUTPUT
            echo "security-details=No vulnerabilities found" >> $GITHUB_OUTPUT
          else
            echo "security-status=failed" >> $GITHUB_OUTPUT
            echo "security-details=${HIGH_VULNS} high, ${MODERATE_VULNS} moderate vulnerabilities" >> $GITHUB_OUTPUT
            echo "::error::Security vulnerabilities detected: ${HIGH_VULNS} high, ${MODERATE_VULNS} moderate"
            exit 1
          fi

      - name: Build and Security Generation
        if: matrix.check == 'build'
        run: |
          echo "üèóÔ∏è Running hardened build..."
          npm run security:generate

          # Build with environment-specific flags
          npm run build:staging

          # Validate build artifacts
          if [ ! -d "dist" ]; then
            echo "::error::Build failed - no dist directory"
            exit 1
          fi

          # Security hardening validation
          if find dist -name "*.map" | grep -q .; then
            echo "::error::Source maps found in hardened build!"
            exit 1
          fi

          echo "::set-output name=build-status::success"

      - name: Bundle Size Analysis
        if: matrix.check == 'bundle'
        run: |
          echo "üì¶ Analyzing bundle size..."
          npm run build

          # Get detailed size information
          DIST_SIZE_MB=$(du -sm dist | cut -f1)
          DIST_SIZE_BYTES=$(du -sb dist | cut -f1)

          # Analyze individual chunks
          CHUNK_SIZES=$(find dist -name "*.js" -exec du -sh {} + | sort -hr)

          echo "Total size: ${DIST_SIZE_MB}MB (${DIST_SIZE_BYTES} bytes)"
          echo "Chunk sizes:"
          echo "$CHUNK_SIZES"

          # Evaluate against limits
          WARNING_BYTES=$(( BUNDLE_SIZE_WARNING_MB * 1024 * 1024 ))
          LIMIT_BYTES=$(( BUNDLE_SIZE_LIMIT_MB * 1024 * 1024 ))

          if [ $DIST_SIZE_BYTES -gt $LIMIT_BYTES ]; then
            echo "bundle-status=failed" >> $GITHUB_OUTPUT
            echo "bundle-details=${DIST_SIZE_MB}MB exceeds ${BUNDLE_SIZE_LIMIT_MB}MB limit" >> $GITHUB_OUTPUT
            echo "::error::Bundle size too large: ${DIST_SIZE_MB}MB > ${BUNDLE_SIZE_LIMIT_MB}MB"
            exit 1
          elif [ $DIST_SIZE_BYTES -gt $WARNING_BYTES ]; then
            echo "bundle-status=warning" >> $GITHUB_OUTPUT
            echo "bundle-details=${DIST_SIZE_MB}MB approaching limit" >> $GITHUB_OUTPUT
          else
            echo "bundle-status=success" >> $GITHUB_OUTPUT
            echo "bundle-details=${DIST_SIZE_MB}MB within limits" >> $GITHUB_OUTPUT
          fi

      - name: Upload Check Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: quality-results-${{ matrix.check }}
          path: |
            dist/
            coverage/
            reports/
          retention-days: 7

  quality-summary:
    name: Quality Gates Summary
    needs: quality-checks
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: Generate Quality Report
        run: |
          echo "# üìä Quality Gates Summary"
          echo "| Check | Status | Details |"
          echo "|-------|--------|--------|"

          # Download all artifacts
          mkdir -p reports

          # Parse results (would need artifact downloads in real implementation)
          echo "‚úÖ Quality validation completed"
          echo "üìà All checks processed"

  deployment-verification:
    name: Deploy Verification
    needs: [quality-checks, quality-summary]
    runs-on: ubuntu-latest
    if: github.event_name == 'push'

    steps:
      - name: Verify Staging Deployment
        run: |
          echo "üåê Verifying staging deployment..."

          # Only run if staging URL is configured
          STAGING_URL="${{ secrets.STAGING_URL }}"

          if [ -z "$STAGING_URL" ]; then
            echo "‚ö†Ô∏è  Staging URL not configured - skipping verification"
            echo "::warning::Add STAGING_URL secret to enable deployment verification"
            exit 0
          fi

          # Validate URL scheme to avoid unexpected curl targets (file://, ssh://, etc.)
          if ! printf '%s' "$STAGING_URL" | grep -Eq '^https?://'; then
            echo "::error::Invalid STAGING_URL (must start with http:// or https://)"
            exit 1
          fi

          # Enhanced health check with better error handling
          echo "üîç Testing staging endpoint: $STAGING_URL"

          # Retry logic with exponential backoff
          MAX_RETRIES=3
          RETRY_COUNT=0

          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" \
              --connect-timeout 10 \
              --max-time 30 \
              "$STAGING_URL" || echo "000")
            
            if [ "$HTTP_CODE" = "200" ]; then
              echo "‚úÖ Health check passed (attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)"
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                SLEEP_TIME=$((2 ** RETRY_COUNT))
                echo "‚è≥ Attempt failed ($HTTP_CODE), retrying in ${SLEEP_TIME}s..."
                sleep $SLEEP_TIME
              else
                echo "::error::Health check failed after $MAX_RETRIES attempts (last code: $HTTP_CODE)"
                exit 1
              fi
            fi
          done
