name: Quality Gates (Pre-Staging)

permissions:
  contents: read
  pull-requests: write

# Optimized concurrency - branch-based with global limit
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

on:
  push:
    branches: [pre-staging]
  pull_request:
    branches: [pre-staging]

# Global environment variables for all jobs
env:
  NODE_VERSION: "20"
  CACHE_VERSION: "v1"
  BUNDLE_SIZE_LIMIT_MB: "10"
  BUNDLE_SIZE_WARNING_MB: "8"

jobs:
  quality-checks:
    name: Comprehensive Quality Validation
    runs-on: ubuntu-latest
    timeout-minutes: 30

    strategy:
      matrix:
        check: [lint, types, tests, security, build, bundle]
      # Don't cancel other jobs if one fails
      fail-fast: false

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1 # Shallow for faster checkout

      - name: Setup Node.js
        uses: ./.github/actions/cache-vite-npm
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install Dependencies
        run: npm ci --prefer-offline --no-audit

      # FIXED: Separated lint checks - only run linting, not typecheck
      - name: Lint and Format Check
        if: matrix.check == 'lint'
        run: |
          echo "üîç Running lint and format checks..."
          # Run ONLY linting and formatting, not typecheck (that's in the 'types' job)
          npm run check:lint
          npm run check:format

          # Output summary for reporting
          echo "lint-status=success" >> $GITHUB_ENV
          echo "lint-details=All linting checks passed" >> $GITHUB_ENV

      - name: TypeScript Validation
        if: matrix.check == 'types'
        run: |
          echo "üî∑ Running TypeScript validation..."
          # Run typecheck and capture output
          TYPECHECK_OUTPUT=$(npm run typecheck 2>&1 || true)
          echo "$TYPECHECK_OUTPUT"

          # Count TypeScript errors properly
          ERROR_COUNT=$(echo "$TYPECHECK_OUTPUT" | grep -c "error TS" || echo "0")

          # Ensure ERROR_COUNT is a clean numeric value
          ERROR_COUNT=$(echo "$ERROR_COUNT" | sed 's/[^0-9]*//g' | xargs printf "%d" 2>/dev/null || echo "0")

          if [ "${ERROR_COUNT:-0}" -eq 0 ]; then
            echo "type-status=success" >> $GITHUB_ENV
          else
            echo "type-status=failed" >> $GITHUB_ENV
          fi
          echo "type-errors=${ERROR_COUNT:-0}" >> $GITHUB_ENV

      - name: Unit Tests
        if: matrix.check == 'tests'
        run: |
          echo "üß™ Running unit tests..."

          # Debug: Check if test files exist
          echo "üîç Looking for test files..."
          TEST_FILES=$(find client -type f \( -name "*.test.ts" -o -name "*.test.tsx" -o -name "*.spec.ts" -o -name "*.spec.tsx" \) 2>/dev/null || true)

          if [ -z "$TEST_FILES" ]; then
            echo "::warning::No test files found in client directory"
            echo "::warning::Expected patterns: **/*.test.ts, **/*.spec.ts, **/__tests__/*.ts"
            echo "test-status=skipped" >> $GITHUB_ENV
            exit 0
          fi

          echo "Found test files:"
          echo "$TEST_FILES"

          # Count test files
          TEST_COUNT=$(echo "$TEST_FILES" | wc -l)
          echo "üìä Total test files: $TEST_COUNT"

          # Run actual tests with coverage
          echo "‚è≥ Running test suite with coverage..."

          # Run tests - using the exact command that works locally
          npm test -- --coverage

          TEST_EXIT_CODE=$?

          # Report test results
          if [ $TEST_EXIT_CODE -eq 0 ]; then
            echo "test-status=success" >> $GITHUB_ENV
            echo "‚úÖ All tests passed"
          else
            echo "test-status=failed" >> $GITHUB_ENV
            echo "::error::Unit tests failed with exit code $TEST_EXIT_CODE"
            exit 1
          fi

      # UPDATED: More nuanced security audit handling
      - name: Security Audit
        if: matrix.check == 'security'
        run: |
          echo "üõ°Ô∏è Running security audit..."

          # Run audit with JSON output for parsing
          AUDIT_RESULT=$(npm audit --audit-level=moderate --json || true)

          # Extract vulnerability counts
          CRITICAL_VULNS=$(echo "$AUDIT_RESULT" | jq -r '.metadata.vulnerabilities.critical // 0')
          HIGH_VULNS=$(echo "$AUDIT_RESULT" | jq -r '.metadata.vulnerabilities.high // 0')
          MODERATE_VULNS=$(echo "$AUDIT_RESULT" | jq -r '.metadata.vulnerabilities.moderate // 0')

          echo "üìä Vulnerability Summary:"
          echo "  Critical: $CRITICAL_VULNS"
          echo "  High: $HIGH_VULNS"
          echo "  Moderate: $MODERATE_VULNS"

          # STRICT: Fail on critical or high vulnerabilities
          if [ $((CRITICAL_VULNS + HIGH_VULNS)) -gt 0 ]; then
            echo "security-status=failed" >> $GITHUB_ENV
            echo "security-details=${CRITICAL_VULNS} critical, ${HIGH_VULNS} high vulnerabilities" >> $GITHUB_ENV
            echo "::error::CRITICAL/HIGH security vulnerabilities detected: ${CRITICAL_VULNS} critical, ${HIGH_VULNS} high"
            exit 1
          fi

          # LENIENT: Warn on moderate vulnerabilities but don't fail
          # This allows dev dependencies like ESLint to have moderate issues
          if [ $MODERATE_VULNS -gt 0 ]; then
            echo "security-status=warning" >> $GITHUB_ENV
            echo "security-details=${MODERATE_VULNS} moderate vulnerabilities (dev dependencies allowed)" >> $GITHUB_ENV
            echo "::warning::${MODERATE_VULNS} moderate vulnerabilities detected in dev dependencies - please review and update when possible"
            
            # Show details for tracking
            echo "üìã Moderate vulnerability details:"
            npm audit --audit-level=moderate || true
          else
            echo "security-status=success" >> $GITHUB_ENV
            echo "security-details=No vulnerabilities found" >> $GITHUB_ENV
          fi

      - name: Build and Security Generation
        if: matrix.check == 'build'
        run: |
          echo "üèóÔ∏è Running hardened build for staging..."

          # Generate security headers first
          npm run security:generate

          # Build with environment-specific flags (CI mode - skips duplicate checks)
          # Use build:ci:staging if you added it, otherwise just run vite directly
          if npm run | grep -q "build:ci:staging"; then
            npm run build:ci:staging
          else
            # Fallback: run vite build directly to skip the checks
            npx vite build --mode staging && node scripts/setup-cpanel.js
          fi

          # Validate build artifacts
          if [ ! -d "dist" ]; then
            echo "::error::Build failed - no dist directory"
            exit 1
          fi

          echo "‚úÖ Build directory created: dist/"

          # List generated files for verification
          echo "üìÅ Build artifacts:"
          ls -lh dist/ || true

          # Security hardening validation - no source maps in production builds
          if find dist -name "*.map" | grep -q .; then
            echo "::warning::Source maps found in build (may be okay for staging)"
            # Don't fail for staging, but log for awareness
          fi

          echo "build-status=success" >> $GITHUB_ENV

      - name: Bundle Size Analysis
        if: matrix.check == 'bundle'
        run: |
          echo "üì¶ Analyzing bundle size..."

          # Build for production without running checks (they already ran in other jobs)
          # Use CI build script if available, otherwise run vite directly
          if npm run | grep -q "build:ci"; then
            echo "Using CI build script..."
            npm run build:ci
          else
            echo "Running vite build directly..."
            npx vite build --mode production && node scripts/setup-cpanel.js
          fi

          # Verify dist directory exists
          if [ ! -d "dist" ]; then
            echo "::error::Build failed - no dist directory created"
            exit 1
          fi

          # Get detailed size information
          DIST_SIZE_MB=$(du -sm dist | cut -f1)
          DIST_SIZE_BYTES=$(du -sb dist | cut -f1)

          # Analyze individual chunks
          echo "üìä Bundle Size Analysis:"
          CHUNK_SIZES=$(find dist -name "*.js" -exec du -sh {} + | sort -hr | head -n 10)

          echo "Total size: ${DIST_SIZE_MB}MB (${DIST_SIZE_BYTES} bytes)"
          echo ""
          echo "Top 10 largest chunks:"
          echo "$CHUNK_SIZES"

          # Evaluate against limits
          WARNING_BYTES=$(( BUNDLE_SIZE_WARNING_MB * 1024 * 1024 ))
          LIMIT_BYTES=$(( BUNDLE_SIZE_LIMIT_MB * 1024 * 1024 ))

          if [ $DIST_SIZE_BYTES -gt $LIMIT_BYTES ]; then
            echo "bundle-status=failed" >> $GITHUB_ENV
            echo "bundle-details=${DIST_SIZE_MB}MB exceeds ${BUNDLE_SIZE_LIMIT_MB}MB limit" >> $GITHUB_ENV
            echo "::error::Bundle size too large: ${DIST_SIZE_MB}MB > ${BUNDLE_SIZE_LIMIT_MB}MB"
            exit 1
          elif [ $DIST_SIZE_BYTES -gt $WARNING_BYTES ]; then
            echo "bundle-status=warning" >> $GITHUB_ENV
            echo "bundle-details=${DIST_SIZE_MB}MB approaching limit (${BUNDLE_SIZE_WARNING_MB}MB warning threshold)" >> $GITHUB_ENV
            echo "::warning::Bundle size ${DIST_SIZE_MB}MB is approaching the ${BUNDLE_SIZE_WARNING_MB}MB warning threshold"
          else
            echo "bundle-status=success" >> $GITHUB_ENV
            echo "bundle-details=${DIST_SIZE_MB}MB well within limits" >> $GITHUB_ENV
          fi

      - name: Upload Check Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: quality-results-${{ matrix.check }}
          path: |
            dist/
            coverage/
            reports/
          retention-days: 7

  quality-summary:
    name: Quality Gates Summary
    needs: quality-checks
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: Generate Quality Report
        run: |
          echo "# üìä Quality Gates Summary"
          echo "| Check | Status | Details |"
          echo "|-------|--------|--------|"

          # Download all artifacts
          mkdir -p reports

          # Parse results (would need artifact downloads in real implementation)
          echo "‚úÖ Quality validation completed"
          echo "üìà All checks processed"

  deployment-verification:
    name: Deploy Verification
    needs: [quality-checks, quality-summary]
    runs-on: ubuntu-latest
    if: github.event_name == 'push'

    steps:
      - name: Verify Staging Deployment
        run: |
          echo "üåê Verifying staging deployment..."

          # Only run if staging URL is configured
          STAGING_URL="${{ secrets.STAGING_URL }}"

          if [ -z "$STAGING_URL" ]; then
            echo "‚ö†Ô∏è  Staging URL not configured - skipping verification"
            echo "::warning::Add STAGING_URL secret to enable deployment verification"
            exit 0
          fi

          # Validate URL scheme to avoid unexpected curl targets (file://, ssh://, etc.)
          if ! printf '%s' "$STAGING_URL" | grep -Eq '^https?://'; then
            echo "::error::Invalid STAGING_URL (must start with http:// or https://)"
            exit 1
          fi

          # Enhanced health check with better error handling
          echo "üîç Testing staging endpoint: $STAGING_URL"

          # Retry logic with exponential backoff
          MAX_RETRIES=3
          RETRY_COUNT=0
          SUCCESS=false

          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            # Capture both the HTTP status and the final URL in a single request
            read -r HTTP_CODE FINAL_URL <<< "$(curl -L -s -o /dev/null \
              --connect-timeout 10 \
              --max-time 30 \
              -w '%{http_code} %{url_effective}' \
              "$STAGING_URL" 2>/dev/null || echo '000 '"$STAGING_URL")"
            
            # Extract hosts for security validation
            STAGING_HOST=$(printf '%s' "$STAGING_URL" | awk -F/ '{print $3}')
            FINAL_HOST=$(printf '%s' "$FINAL_URL" | awk -F/ '{print $3}')
            
            echo "üìä Response: HTTP $HTTP_CODE"
            if [ "$FINAL_URL" != "$STAGING_URL" ]; then
              echo "üîÄ Redirected to: $FINAL_URL"
            fi
            
            # 1. Security Check: Fail if redirected to an unexpected host
            if [ "$FINAL_HOST" != "$STAGING_HOST" ]; then
              echo "::error::Security Risk: Redirected to unexpected host: $FINAL_HOST"
              SUCCESS=false
              break
            fi

            # 2. Status Check: Using case statement for robust pattern matching
            case "$HTTP_CODE" in
              2* | 3*)
                echo "‚úÖ Health check passed (HTTP $HTTP_CODE)"
                SUCCESS=true
                break
                ;;
              *)
                RETRY_COUNT=$((RETRY_COUNT + 1))
                if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                  SLEEP_TIME=$((2 ** RETRY_COUNT))
                  echo "‚è≥ Attempt $RETRY_COUNT failed (HTTP $HTTP_CODE), retrying in ${SLEEP_TIME}s..."
                  sleep $SLEEP_TIME
                else
                  echo "::error::Health check failed after $MAX_RETRIES attempts"
                  echo "::error::Final HTTP code: $HTTP_CODE"
                  echo "::error::Final URL: $FINAL_URL"
                  
                  # Additional debugging info
                  echo ""
                  echo "üîç Debug information:"
                  echo "   Original URL: [hidden for security]"
                  echo "   Final URL: $FINAL_URL"
                  echo "   HTTP Code: $HTTP_CODE"
                  echo ""
                  echo "üí° Common issues:"
                  echo "   - Host mismatch: Redirected to external site (security risk)"
                  echo "   - 4xx errors: Wrong URL or authentication required"
                  echo "   - 5xx errors: Server down or misconfigured"
                  echo "   - 000: Network, DNS, or SSL issues"
                  
                  SUCCESS=false
                fi
                ;;
            esac
          done

          # Exit with appropriate code
          if [ "$SUCCESS" = true ]; then
            exit 0
          else
            exit 1
          fi
