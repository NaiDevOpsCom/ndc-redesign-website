import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const ROOT_DIR = path.resolve(__dirname, "..");
const POLICY_PATH = path.join(ROOT_DIR, "security-policy.json");
const VERCEL_CONFIG_PATH = path.join(ROOT_DIR, "vercel.json");
const HTACCESS_PATH = path.join(ROOT_DIR, "client", "public", ".htaccess");

function loadPolicy() {
  if (!fs.existsSync(POLICY_PATH)) {
    console.error(`Error: Policy file not found at ${POLICY_PATH}`);
    process.exit(1);
  }
  return JSON.parse(fs.readFileSync(POLICY_PATH, "utf8"));
}

function generateCSPString(cspConfig) {
  const directives = Object.entries(cspConfig)
    .map(([key, value]) => {
      if (key === "upgrade-insecure-requests") {
        return value ? key : "";
      }
      if (Array.isArray(value)) {
        return `${key} ${value.join(" ")}`;
      }
      return "";
    })
    .filter(Boolean);

  return directives.join("; ") + ";";
}

function updateVercelConfig(policy) {
  let vercelConfig = {};
  if (fs.existsSync(VERCEL_CONFIG_PATH)) {
    vercelConfig = JSON.parse(fs.readFileSync(VERCEL_CONFIG_PATH, "utf8"));
  }

  const cspString = generateCSPString(policy.contentSecurityPolicy);

  const headers = [
    {
      key: "Content-Security-Policy",
      value: cspString,
    },
    ...Object.entries(policy.headers).map(([key, value]) => ({
      key,
      value,
    })),
  ];

  // Update or add the headers section for source "/(.*)"
  vercelConfig.headers = vercelConfig.headers || [];
  const headerRuleIndex = vercelConfig.headers.findIndex((h) => h.source === "/(.*)");

  const newHeaderRule = {
    source: "/(.*)",
    headers,
  };

  if (headerRuleIndex >= 0) {
    vercelConfig.headers[headerRuleIndex] = newHeaderRule;
  } else {
    vercelConfig.headers.push(newHeaderRule);
  }

  fs.writeFileSync(VERCEL_CONFIG_PATH, JSON.stringify(vercelConfig, null, 2));
  console.log(`Updated Vercel config at ${VERCEL_CONFIG_PATH}`);
}

function generateHtaccess(policy) {
  const cspString = generateCSPString(policy.contentSecurityPolicy);

  const rules = [
    "<IfModule mod_headers.c>",
    `  Header set Content-Security-Policy "${cspString}"`,
    ...Object.entries(policy.headers).map(([key, value]) => `  Header set ${key} "${value}"`),
    "</IfModule>",
  ];

  const content = `# ==============================================================================
# SECURITY HEADERS (AUTO-GENERATED)
# ==============================================================================
# This file is automatically generated from 'security-policy.json'.
# DO NOT EDIT THIS FILE DIRECTLY.
#
# To update security policies:
# 1. Modify 'security-policy.json' in the project root.
# 2. Run 'npm run security:generate' (or 'npm run build').
#
# Documentation: https://github.com/nairobi-devops/ndc-redesign-website/blob/main/docs/SECURITY.md
# ==============================================================================

${rules.join("\n")}

# SPA Routing Rules
<IfModule mod_rewrite.c>
  RewriteEngine On
  RewriteBase /
  RewriteRule ^index\.html$ - [L]
  RewriteCond %{REQUEST_FILENAME} !-f
  RewriteCond %{REQUEST_FILENAME} !-d
  RewriteCond %{REQUEST_FILENAME} !-l
  RewriteRule . /index.html [L]
</IfModule>
`;

  // Ensure directory exists
  const dir = path.dirname(HTACCESS_PATH);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }

  fs.writeFileSync(HTACCESS_PATH, content);
  console.log(`Generated .htaccess at ${HTACCESS_PATH}`);
}

function main() {
  console.log("Generating security headers...");
  const policy = loadPolicy();

  updateVercelConfig(policy);
  generateHtaccess(policy);

  console.log("Done.");
}

main();
